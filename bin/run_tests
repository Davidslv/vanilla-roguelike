#!/usr/bin/env ruby
# Comprehensive test runner for Vanilla game
# Executes all testing mechanisms: RSpec tests, game simulator tests, etc.

require 'optparse'
require 'fileutils'
require 'open3'
require 'time'

# Directory for storing test results
RESULTS_DIR = File.join(Dir.pwd, 'test_results')
FileUtils.mkdir_p(RESULTS_DIR) unless Dir.exist?(RESULTS_DIR)

# Options with sensible defaults
options = {
  verbose: false,
  seed: Random.new_seed,
  fast: false,
  skip_rspec: false,
  skip_game_tests: false,
  output_dir: RESULTS_DIR,
  timestamp: Time.now.strftime('%Y%m%d_%H%M%S')
}

# Parse command line options
OptionParser.new do |opts|
  opts.banner = "Usage: bin/run_tests [options]"

  opts.on("-v", "--verbose", "Show detailed test output") do
    options[:verbose] = true
  end

  opts.on("-s", "--seed SEED", "Set random seed for tests (for reproducibility)") do |seed|
    options[:seed] = seed.to_i
  end

  opts.on("-f", "--fast", "Run tests in fast mode") do
    options[:fast] = true
  end

  opts.on("--skip-rspec", "Skip RSpec tests") do
    options[:skip_rspec] = true
  end

  opts.on("--skip-game", "Skip game simulator tests") do
    options[:skip_game_tests] = true
  end

  opts.on("-o", "--output-dir DIR", "Output directory for test results") do |dir|
    options[:output_dir] = dir
    FileUtils.mkdir_p(options[:output_dir]) unless Dir.exist?(options[:output_dir])
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end.parse!

# Base output file path
output_base = File.join(options[:output_dir], "vanilla_tests_#{options[:timestamp]}")

# Results tracking
results = {
  passed: [],
  failed: [],
  start_time: Time.now
}

# Helper function to run a command and process its output
def run_command(cmd, options, label, results, direct_output = false)
  puts "\n#{'=' * 80}"
  puts "RUNNING: #{label}"
  puts "#{'=' * 80}"

  output_file = "#{options[:output_dir]}/#{label.downcase.gsub(/\s+/, '_')}_#{options[:timestamp]}.log"

  # Track start time
  start_time = Time.now
  success = false

  if direct_output
    # Run with direct output to console for better visibility (especially for RSpec)
    puts "\n" # Add some spacing

    # Run the command and let the output go directly to the console
    # while still capturing it for the log file
    output = []
    IO.popen(cmd) do |io|
      while line = io.gets
        puts line  # Direct output to console
        output << line
      end
    end
    success = $?.success?

    # Write the captured output to the log file
    File.write(output_file, output.join)
  else
    # Run the command and capture its output
    Open3.popen3(cmd) do |stdin, stdout, stderr, wait_thread|
      # Write output to both console (if verbose) and log file
      File.open(output_file, 'w') do |f|
        while stdout_line = stdout.gets
          puts stdout_line if options[:verbose]
          f.puts stdout_line
        end

        while stderr_line = stderr.gets
          puts stderr_line if options[:verbose]
          f.puts "ERROR: #{stderr_line}"
        end
      end

      # Check if command succeeded
      success = wait_thread.value.success?
    end
  end

  # Process result
  duration = Time.now - start_time
  status = success ? "PASSED" : "FAILED"
  puts "\n#{label}: #{status} (#{duration.round(2)}s)"

  # Store result
  if success
    results[:passed] << { label: label, duration: duration, log: output_file }
  else
    results[:failed] << { label: label, duration: duration, log: output_file }
  end

  return success
end

# Write summary report
def write_summary(results, output_file)
  File.open(output_file, 'w') do |f|
    f.puts "VANILLA TEST RESULTS SUMMARY"
    f.puts "=" * 80
    f.puts "Generated: #{Time.now}"
    f.puts "Test Run Duration: #{(Time.now - results[:start_time]).round(2)} seconds"
    f.puts "=" * 80

    # Test results
    f.puts "\nPASSED TESTS (#{results[:passed].length})"
    f.puts "-" * 80
    results[:passed].each do |test|
      f.puts "✓ #{test[:label]} (#{test[:duration].round(2)}s)"
    end

    f.puts "\nFAILED TESTS (#{results[:failed].length})"
    f.puts "-" * 80
    results[:failed].each do |test|
      f.puts "✗ #{test[:label]} (#{test[:duration].round(2)}s)"
      f.puts "  Log: #{test[:log]}"
    end

    # Overall result
    if results[:failed].empty?
      f.puts "\n✅ ALL TESTS PASSED"
    else
      f.puts "\n❌ #{results[:failed].length} TESTS FAILED"
    end
  end
end

# Header
puts "\nVANILLA COMPREHENSIVE TEST RUNNER"
puts "=================================="
puts "Seed: #{options[:seed]}"
puts "Timestamp: #{options[:timestamp]}"
puts "Mode: #{options[:fast] ? 'Fast' : 'Normal'}"
puts "Output directory: #{options[:output_dir]}"
puts "==================================\n"

# 1. Run the game simulator tests first
unless options[:skip_game_tests]
  # Basic movement test
  movement_test_cmd = "ruby bin/test_game -s #{options[:seed]}"
  movement_test_cmd += " -f" if options[:fast]
  movement_test_cmd += " -o #{options[:output_dir]}/movement_test_#{options[:timestamp]}.log"
  run_command(movement_test_cmd, options, "Movement Tests", results)

  # Add any other test_game variants here
  # For example, if you have stairs testing:
  stairs_test_cmd = "ruby bin/test_game -s #{options[:seed]} --test-stairs"
  stairs_test_cmd += " -f" if options[:fast]
  stairs_test_cmd += " -o #{options[:output_dir]}/stairs_test_#{options[:timestamp]}.log"
  run_command(stairs_test_cmd, options, "Stairs Tests", results) if File.exist?('bin/test_game') &&
    File.read('bin/test_game').include?('--test-stairs')
end

# 2. Run RSpec tests last, with direct output to console
unless options[:skip_rspec]
  rspec_command = "bundle exec rspec"

  # Add format documentation regardless of verbose flag
  # This ensures the typical RSpec output that users are familiar with
  rspec_command += " --format documentation"

  # Use color output if not being redirected to a file
  rspec_command += " --color"

  # Pass the direct_output flag as true to display RSpec results directly
  run_command(rspec_command, options, "RSpec Tests", results, true)
end

# 3. Write summary report
summary_file = "#{output_base}_summary.txt"
write_summary(results, summary_file)

# 4. Print final results
puts "\n#{'=' * 80}"
puts "TEST RESULTS SUMMARY"
puts "#{'=' * 80}"
puts "Tests Passed: #{results[:passed].length}"
puts "Tests Failed: #{results[:failed].length}"
puts "Total Duration: #{(Time.now - results[:start_time]).round(2)} seconds"
puts "Detailed Summary: #{summary_file}"
puts "#{'=' * 80}"

# Report test failures to the shell with a non-zero exit code if any test failed
if results[:failed].any?
  puts "\n❌ Some tests failed! Check the logs for details."
  exit 1
else
  puts "\n✅ All tests passed!"
  exit 0
end