#!/usr/bin/env ruby
# Simple game test script focused on basic movement test only

require_relative '../lib/vanilla'
require_relative '../lib/vanilla/simulation/game_simulator'

# Parse command line arguments
require 'optparse'

options = {
  seed: Random.new_seed,
  verbose: false,
  delay: 0.5,
  output_file: nil,  # Default to console output
  test_type: :movement  # Default test type
}

OptionParser.new do |opts|
  opts.banner = "Usage: bin/test_game [options]"

  opts.on("-s", "--seed SEED", "Set random seed for tests") do |seed|
    options[:seed] = seed.to_i
  end

  opts.on("-v", "--verbose", "Show detailed output") do
    options[:verbose] = true
  end

  opts.on("-d", "--delay DELAY", "Delay between actions (seconds)") do |delay|
    options[:delay] = delay.to_f
  end

  opts.on("-f", "--fast", "Run quickly (0.1 second delay)") do
    options[:delay] = 0.1
  end

  opts.on("-o", "--output FILE", "Write output to file") do |file|
    options[:output_file] = file
  end

  opts.on("--test-stairs", "Test stairs functionality") do
    options[:test_type] = :stairs
  end

  opts.on("-h", "--help", "Show this help") do
    puts opts
    exit
  end
end.parse!

# Set up output capture if needed
if options[:output_file]
  original_stdout = $stdout
  $stdout = File.open(options[:output_file], 'w')
  puts "Writing output to: #{options[:output_file]}"
  puts "Running test non-interactively"
end

puts "Running #{options[:test_type]} test with seed: #{options[:seed]}"

# Create game simulator with non-interactive mode
puts "Creating game simulator..."
simulator = Vanilla::Simulation::GameSimulator.new(
  seed: options[:seed],
  capture_output: true  # Always capture output for non-interactive testing
)

# Define test actions based on the selected test type
case options[:test_type]
when :movement
  # Define the movement test action
  test_action = lambda do |sim|
    # Forcibly set the display_rendering to false to avoid interactive rendering
    sim.instance_variable_set(:@display_rendering, false) if sim.instance_variable_defined?(:@display_rendering)

    puts "Setting up game..."
    sim.setup_game

    # Verify initial player rendering
    puts "Checking initial player rendering..."
    initial_render = sim.verify_player_rendering
    puts "Initial player rendering correct: #{initial_render}"

    # Capture initial screen
    puts "Capturing initial screen..."
    sim.capture_screen

    puts "Testing movement in all directions..."

    # Get the level and grid for debugging
    level = sim.instance_variable_get(:@level)
    grid = level.grid if level

    # Print debug info about the grid
    puts "DEBUG: Grid object: #{grid.class} #{grid.object_id}" if grid

    # Check if direction symbols are being affected
    test_directions = [:up, :right, :down, :left]
    puts "DEBUG: Directions before loop:"
    test_directions.each do |d|
      puts "  - #{d.inspect} is a #{d.class} with object_id #{d.object_id}"
    end

    # Now test each direction
    # IMPORTANT: Each direction must be passed as a Symbol (:up, :right, :down, :left)
    # Do NOT pass the grid object as a direction, or you'll encounter:
    # NoMethodError: undefined method 'to_sym' for #<Vanilla::MapUtils::Grid:...>
    test_directions.each do |direction|
      puts "Moving #{direction}..."
      sleep options[:delay]

      begin
        # Print debug info right before passing to simulate_movement
        puts "DEBUG: About to pass direction: #{direction.inspect} (#{direction.class}, #{direction.object_id})"

        # Call simulate_movement with the direction symbol - this gets translated to
        # cardinal directions (:north, :south, :east, :west) inside the simulator
        results = sim.simulate_movement(direction, 1)

        if results && results.first
          success = results.first[:moved]
          puts "Movement #{direction}: #{success ? 'Success' : 'Failed'}"
        else
          puts "Movement #{direction}: No results returned"
        end
      rescue => e
        puts "Error moving #{direction}: #{e.message}"
        puts "Backtrace:"
        puts e.backtrace.first(10) # Show up to 10 lines of backtrace
      end
    end

    puts "Test completed successfully!"
  end

when :stairs
  # Define the stairs test action
  test_action = lambda do |sim|
    # Forcibly set the display_rendering to false to avoid interactive rendering
    sim.instance_variable_set(:@display_rendering, false) if sim.instance_variable_defined?(:@display_rendering)

    puts "Setting up game for stairs test..."
    sim.setup_game

    # Verify initial player rendering
    puts "Checking initial player rendering..."
    initial_render = sim.verify_player_rendering
    puts "Initial player rendering correct: #{initial_render}"

    # Attempt to create and use stairs
    puts "Testing stairs functionality..."
    success = sim.guaranteed_level_transition
    puts "Stairs test: #{success ? 'Success' : 'Failed'}"

    puts "Test completed."
  end
end

# Run the test
puts "Running test..."
results = simulator.run([{ type: :custom, block: test_action }])

# Print summary
puts "\nTest Summary:"
puts "Actions completed: #{results[:actions_completed]}"
puts "Movement attempts: #{results[:movement_attempts] || 0}"
puts "Successful movements: #{results[:successful_movements] || 0}"

# Print stairs-specific results if applicable
if options[:test_type] == :stairs
  puts "Levels completed: #{results[:levels_completed] || 0}"
end

# Display errors if any
if results[:errors] && !results[:errors].empty?
  puts "\nErrors encountered:"
  results[:errors].each do |error|
    puts "- #{error[:error]}: #{error[:message]}"
  end
else
  puts "\nNo errors encountered."
end

# Clean up output file if we're using one
if options[:output_file] && $stdout != STDOUT && $stdout != original_stdout
  $stdout.close
  $stdout = original_stdout
  puts "Test completed. Results written to #{options[:output_file]}"
end

# Exit with appropriate status code
exit(results[:errors] && !results[:errors].empty? ? 1 : 0)